# Mysql索引

## 索引

**哈希索引**

- 把每行数据计算出一个哈希码，存入索引中，哈希表中有指向表的指针。

- 查询快；哈希索引`无法排序、范围查找`，不支持索引列匹配查找。

**Btree**

多路平衡搜索树

**每个节点存储数据和指针信息**

每页存储的空间有限，如果data较大，导致key存储的数量较少。同时B树很深，增加了I/O次数

```
平衡搜索树：左子树<根节点<右子树，任何一个节点左右子树高度差不超过1，保证增删改查的复杂度稳定在O(logN)
```

**B+Tree**

**叶子节点存储数据信息，中间节点存储数据指针信息。**

每个节点可以存储更多key；关键字从小到大排序；查询的速度稳定；节点上的数据排序，范围查找有优势；全节点遍历快，遍历所有的叶子节点即可，不用像B树遍历每个节点。

![img](https://img-blog.csdnimg.cn/20190905145443436.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MjYxMTMw,size_16,color_FFFFFF,t_70)

**全文索引:** 适用于文本场景,记录关键词的索引位置

## 索引类型

普通索引：加速查询

唯一索引：索引字段必须唯一

主键索引：主键本质就是唯一索引 + 非空约束

联合索引：主键包含多个列，遵循最左前缀原则

## 索引失效场景

like%
or 前后索引不一致
and 最左匹配
数据隐式转化 varchar-int

## 最左匹配原则

联合索引 a,b,c===a 、a|b 、 a|b|c

## 前缀索引

索引需要存储的值太长，取前段部分字符（varchar，text，blob）

## 聚簇索引与非聚簇索引的区别（主键索引&非主键索引）

聚簇索引：逻辑顺序与磁盘上的物理存储顺序相同，在表中唯一性约束。在叶子节点上的data域记录着数据的所有信息

非聚簇索引：逻辑顺序与磁盘上的物理存储顺序不相同。在**辅助索引**的叶子节点上的data域记录着数据的主键值，查询时先查询主键值，在去**主索引**上查找其他数据。

## 红黑树和B+树

红黑树高度不一致，I/O不稳定

B+树高度一致，可以排序查询

## 索引优化的方法

1. 多列索引（需要多个列作为条件查询）
2. 把选择性最强的索引放在最前面，选择性==区分度
3. 前缀索引
4. 覆盖索引：所有需要查询的字段信息都包含在索引里面。覆盖索引会直接在索引表中查询不会访问原始数据

## Mysql引擎(Innodb&MyISAM)

1. innodb支持事物，MyISAM不支持事物。事物可以并发执行
2. innodb支持外键，MyISAM不支持外键。外键是子表的主键，两张表连接。
3. InnoDB是聚簇索引，MyISAM是非聚簇索引。InnoDB的数据文件存放在主索引的叶子节点上，本身就是索引文件。MyISAM的索引保存的是数据文件的指针
4. InnoDB最小锁粒度是行锁，MyISAM的最小锁粒度是表锁。MyISAM一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞。

| 引擎   | 特性                                                         |
| ------ | ------------------------------------------------------------ |
| MYISAM | 不支持外键，表锁，插入数据时，锁定整个表，查表总行数时，不需要全表扫描 |
| INNODB | 支持外键，行锁，查表总行数时，全表扫描                       |

![https//uploadfilesnowcodercom/files/20211202/5509581361638430848173/1608262635754png](https://img-blog.csdnimg.cn/img_convert/e8a05231954b11e263b5fda5c706e604.png)

# 数据库基础

## where having

where在分组前对数据进行过滤，having在分组后对数据进行过滤

having可以使用聚合函数

## 关系型数据库& 非关系数据库

**关系型数据库**：二维表模型

**非关系型数据库**：键值存储，结构不稳定。

分类：1.高性能并发的k-v数据库，redis；2.海量数据访问的面向文档数据库，mongodb；3.可拓展的分布式数据库。

## sql查询过程

![https//mmbizqpiccn/mmbiz/eQPyBffYbueoJM5VHHDBh8Uf3cgajREphROFOHH1G7ysKEzLdNMfj9iasuys56US6icruBAkTiaNsxZlvOKrQ0icJg/640?wxfmt=jpeg&tp=webp&wxfrom=5&wxlazy=1&wxco=1](https://img-blog.csdnimg.cn/img_convert/53541bcce00e1c8dd138b2e4d7d493b6.png)

## 视图

版本数据

## Drop,truncate,delete

|          |                                                     |
| -------- | --------------------------------------------------- |
| Drop     | 删除表结构与内容，不能带where，不可回滚，速度快     |
| Truncate | 删除表内容，结构保留，不能带where，不可回滚，速度快 |
| Dalete   | 删除表内容，逐行删除，带where，可回滚，速度慢       |

## char&varchar&text

| 名称    | 特性                                       | 实例           |
| ------- | ------------------------------------------ | -------------- |
| char    | 长度固定。查询速度最快                     | 身份证、手机号 |
| varchar | 长度不固定，内容头部会有1或2个字节存储长度 |                |
| text    | 长度不设置，查询速度最慢                   |                |

## MVCC快照读

视图版本数据

## count(*) 和 count(1) 、count(主键)、 count(column)的区别

`count(字段)` < `count(主键id)`< `count(1)` ≈ `count(*)`

count(*) 按行累加计数。

count（主键id）innodb引擎遍历整张表，把id值取出来返回给server层。server层对于返回的每一行，判断是不是为空。

count（1） innodb引擎遍历整张表，server层对于返回的每一行，放一个数字”1“进去，判断是不是为空。

count（column） 只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是只空字符串或者0，而是表示null）的计数，即某个字段值为NULL时，不统计。


# Mysql事物

## 三大范式

1NF 原子性，所有的字段值都是不可再分的

2NF 所有非主键的属性都完全依赖于主键。表之间可能有依赖关系（eg：学生表与专业表都挑选学号做主键）

3NF 每个属性与主键有直接关系，消除传递依赖。（eg：学生表与专业表完全无传值依赖）

## 事物ACID

数据库的操作，主要目的是为了保证数据库的一致性

特性

| 持久性 | 事物操作的变化是永久的           | redolog实现，当系统出现任务问题，redo log把数据恢复 |
| ------ | -------------------------------- | --------------------------------------------------- |
| 原子性 | 事物要不全部完成，要么全部不完成 | undolog事物执行过程中出现问题，undo回滚到初始状态   |
| 一致性 | 事物的操作是前后状态一致的       | 回滚与重做实现。                                    |
| 隔离性 | 事物并发执行是隔离的，互不干扰   | 事物并发执行，锁与MVVC（多版本并发控制）实现        |

## 事物并发执行问题

| 问题   | 说明                                         |
| ------ | -------------------------------------------- |
| 脏读   | 事务A读了B更新的数据，然后B回滚              |
| 重复读 | 多次读取但中途提交修改，导致读取的结果不一致 |
| 幻读   | 多次读取时表结构发生变化                     |

## SQL的事物隔离级别

多个事务读可能会导致以下问题：
脏读：事务B读取事务A还没有提交的数据
不可重复读：一行被检索两次，并且该行中的值在不同的读取之间不同时
幻读:当在事务处理过程中执行两个相同的查询，并且第二个查询返回的行集合与第一个查询不同时
这两个区别在于，不可重复读重点在一行，幻读的重点 ，返回的集合不一样

**隔离级别**

| **隔离级别** | 现象                       | 策略                 | 问题                   |
| ------------ | -------------------------- | -------------------- | ---------------------- |
| 读未提交     | 能读取别的事务未提交的数据 |                      | 幻读，不可重复读，脏读 |
| 读已提交     | 只能读取已经提交的事务     |                      | 幻读，不可重复读       |
| 可重复读     | 多次读取相同行，结果一致   | 读写锁<br />MVCC     | 幻读                   |
| 串行化       | 严格串行执行               | 读的每一行都加悲观锁 | 无                     |

# Mysql锁机制

## 全局锁

所有表只读状态，主要用于全库逻辑备份。缺点是业务停滞状态，无法update

可重复读隔离级别可以避免问题。备份之前开启可重复读的事物。

## 表级锁

### 表锁

- 共享读锁：读锁。仅阻塞其他用户的写操作，允许读操作。

- 独占写锁：写锁。阻塞其他用户的读和写操作。

### 元数据锁（MDL）

对一张表做CRUD操作时，加MDL读锁。

对一张表结构操作时，加MDL写锁

### 意向锁

在对表里某些数据加共享锁和独占锁之前对表加上意向锁，执行更新插入删除时，加意向锁。意向锁的作用是为了判断表中是否有记录被加锁。

eg：事物A给表中某条数据只让读，不让写；事物B申请整个表的写锁。就会冲突。需要判断表中是否有数据加锁了，便利耗时，用意向锁提起判断。

#### AUTO-INC锁

- 插入数据时，加一个表级的auto-inc锁，不在事务提交后释放，在执行完插入语句后立即释放

- 对大量数据插入时，影响插入性能，另一个事务插入会被阻塞。

## 行锁（锁索引）

**Record 记录锁**：锁的是记录本身

**Gap 间隙锁**：锁的是记录之间的间隙，以防止其他事务在这个空隙间插入新的数据，从而避免幻读现象。

**Next-key**（innodb的“间隙锁”） record+Gap 把范围内的数据锁住，其他事物无法插入范围内的数据。ps：锁的是索引而非数据本身。

## MVCC解决幻读

**前提**：在**可重复读隔离**级别下，select查询是**快照读**，启用select事物时，会创建一个试图（版本数据），快照读读的是视图里面的数据。若有其他事物update数据是不会看到的。而update，insert等操作是**当前读**。讨论可重复读隔离级别的欢度现象，建立在**当前读**情况下。

Mysql使用行锁**next-key**解决幻读，当锁住范围行数s据时，其他事物插入数据就会阻塞，解决幻读的问题。

## 乐观锁&悲观锁

乐观锁：出现问题时才加锁。
悲观锁：事务执行时就加锁。

## 数据库死锁

| 互斥条件     | 一个资源只能被一个进程所使用                               | 必须条件，无法预防                                           |
| ------------ | ---------------------------------------------------------- | ------------------------------------------------------------ |
| 保持和请求   | 一个进程使用完一个资源可以请求其他资源，之前的资源依旧占有 | 1.进程请求其他资源时释放已使用的资源<br />2.进程一次性占用所有需要的资源，其他进程无法使用 |
| 不可抢占资源 | 进程已获得的资源使用完成之前不能被抢占                     | 释放已占有的资源                                             |
| 循环等待     | 进程-资源循环链                                            | 规定每个进程必须按序号递增的顺序请求资源                     |


# Mysql架构

## 日志机制

**回滚日志**：MVCC使用的快照存储到undo log中，日志通过一个回滚指针把数据行的所有快照连接起来。对某个记录更新时，会把当前记录写入undo日志中。需要回滚时，回滚指针反过来执行指令就可以回滚。

**重做日志**：记录在数据页上的修改。

- 当数据库的数据修改的时候，修改内容更新到内存后在redolog上添加一条记录，状态为prepare，commit提交事务以后，此次事务的记录状态变成commit状态，最终写入磁盘。

- redolog需要写入磁盘，顺序IO。

- redolog采用循环写的方式记录，当写到结尾时，会回到开头循环写日志。

- 当数据库发生宕机后，可以通过redolog把未落盘的数据恢复。

**binlog**：记录数据库表结构和数据的变更。

- 在server实现，追加的方式写入。用于数据复制、数据恢复。

- 每次提交事务，都会写binlog

## 逻辑架构

![](https://img-blog.csdnimg.cn/img_convert/e2574800fd8f84b2e28152bcd5cbe129.png)

- 客户端：
  
- 服务层：
  
- 存储引擎：数据的存储与提取
  

## Mysql优化

- 读写分离

集群的概念，业务数据库作为master，数据库集群中有主机和从机。主机主要负责写的事物，从机主要负责读的业务。从库可以做索引优化查询。问题：主从同步，分配机制

- 主从同步
  

1. 二次读主库，从读库没有读到数据便去主库读
  
2. 写之后马上读操作访问主库
  
3. 主库重要业务的读写，从库非重要业务的读。


- 分配机制
  
- 创建高性能索引
  

## 大表数据查询优化

- 查询语句加上范围限定条件
  
- 优化sql语句，添加索引
  
- 加缓存，redis
  
- 主从复制，读写分离
  
- 垂直拆分，可以通过三大范式把表拆分
  
- 水平拆分，使用分布式把表分库。
  

## Mysql主从复制

[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-etcdOL8H-1646209104828)(file://C:\Users\Lenovo\AppData\Roaming\marktext\images\2022-01-19-15-47-44-image.png)]

主数据库：所有操作以”事件“的方式记录在**二进制日志**中

从数据库：开启一个I/O线程保存通信，且监控主数据库的**二进制日志**变化。如果发生变化，把变化写入自己的中继日志中。执行一个sql线程把相关事件写入自己的数据库中，实现主从复制。

## 读写分离

![https//imgblogcsdnnet/20171213165317075?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzQyMTYyOQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast](https://img-blog.csdn.net/20171213165317075?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzQyMTYyOQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

# Redis

## 数据结构类型

基本数据结构：String、 list、set、zset和hash，三种特殊数据类型：位图(bitmaps) 、计数器(hyperloglogs)和地理空间(geospatial indexes)。

String：一般常用在需要计数的场景，比如用户的访问次数、热点文章的点赞转发数量等等。

list：发布与订阅或者说消息队列、慢查询。

hash：系统中对象数据的存储。

set：需要存放的数据不能重复以及需要获取多个数据源交集和并集等场景

zset：需要对数据根据某个权重进行[排序](/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F)的场景。比如在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息。

## 缓存雪崩，击穿，穿透

1、缓存雪崩：原有的缓存失效，新缓存未到期间

- 大量缓存数据在同一时间过期
  
- redis故障宕机->大量操作直接访问数据库
  
- 解决方法：加锁，防止大量线程对数据库一次性读写。
  

2、缓存击穿：热点数据缓存过期，请求直接访问数据库，高并发请求把数据库冲垮

3、缓存穿透：数据既不在缓存也不在数据库，在缓存中查询完又去数据库中查询，进行了两次无用查询。

- 解决方法：1、布隆过滤器。把所有可能存在的情况哈希到一个bitmap中，不存在的数据会被拦截掉；2、把不存在的数据缓存，下次查询的时候直接返回null

4、缓存更新

## redis为什么快

1. 数据存储与内存
  
2. 单线程
  
3. 使用多路复用I/O
  
4. 支持多种数据结构


## redis持久化

redis把内存中的数据同步到硬盘文件中保证数据持久化。

实现：单独fork一个子进程，把当前父进程的数据复制到子进程中，然后由子进程写入临时文件中，持久化过程借宿了用这个临时文件替换历史快照文件，子进程退出，释放内存

RDB：按照一定周期把内存的数据以快照文件的形式保存在硬盘的二进制文件。

AOF：redis会将每一个写命令通过write函数追加到文件最后（类似binlog）。当redis重启时

## 缓存与数据库双写数据一致性

1. 先删除缓存再更新数据库

  问题：删除缓存后，数据库更完成之前，如果有请求，会读取旧数据并且写入缓存中。

2. 先更新数据库再删除缓存

  问题：在数据库更新和删除缓存期间，请求读的是旧数据。数据库更新完成就会恢复一致

3. 异步更新缓存

  把更新命令封装成消息丢到消息队列中由Redis自己更行。